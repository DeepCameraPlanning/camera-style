"""
This script converts RGB flow frames generated by Unity to flow field tensor
files.
"""
import argparse
from glob import glob
import os
import os.path as osp
from typing import Tuple

import cv2
import matplotlib.pyplot as plt
import numpy as np
from tqdm import tqdm
import torch

from src.utils.utils import create_dir, save_pth


def divide(a: np.array, b: np.array) -> np.array:
    res = np.divide(
        a,
        b,
        out=np.zeros_like(a, dtype=np.float64),
        where=(b != 0),
    )
    return res


def rgb_to_hsv(bgr_frame: np.array) -> Tuple[np.array, np.array, np.array]:
    """
    Convert a RGB frame to a HSV frame.
    Adapted from: https://github.com/opencv/opencv/blob/17234f82d025e3bbfbf61
    1089637e5aa2038e7b8/3rdparty/openexr/Imath/ImathColorAlgo.cpp
    """
    r_index, g_index, b_index = 0, 1, 2
    r_channel = bgr_frame[:, :, r_index]
    g_channel = bgr_frame[:, :, g_index]
    b_channel = bgr_frame[:, :, b_index]

    max_channel_arg = np.argmax(bgr_frame, axis=-1)
    max_channel = np.max(bgr_frame, axis=-1)
    min_channel = np.min(bgr_frame, axis=-1)
    range_channel = max_channel - min_channel
    zero_channel = np.zeros_like(r_channel, dtype=np.float64)
    sat = zero_channel
    hue = zero_channel

    val = max_channel
    sat = np.multiply(max_channel != 0, range_channel / max_channel)

    sat_mask = sat != 0
    # Case 1: max channel is red
    h_r = np.multiply(
        sat_mask,
        np.multiply(
            max_channel_arg == r_index,
            divide(g_channel - b_channel, range_channel),
        ),
    )
    # Case 2: max channel is green
    h_g = np.multiply(
        sat_mask,
        np.multiply(
            max_channel_arg == g_index,
            2 + divide(b_channel - r_channel, range_channel),
        ),
    )
    # Case 3: max channel is blue
    h_b = np.multiply(
        sat_mask,
        np.multiply(
            max_channel_arg == b_index,
            4 + divide(r_channel - g_channel, range_channel),
        ),
    )
    hue = np.multiply(sat_mask, (h_r + h_b + h_g) / 6)
    hue += np.multiply(sat_mask, np.multiply(hue < 0, 1))

    return hue, sat, val


def frame_to_flow(rgb_frame: np.array) -> np.array:
    """Convert a RGB flow frame into flow field."""
    # Convert BGR frame to HSV
    hue, _, val = rgb_to_hsv(rgb_frame)

    # Get polar module and angle from hue and value encoding
    theta = (2 * hue + 1) * np.pi
    r = val / 10

    # Convert polar coordinates to euclidean coordinates
    x = r * np.cos(theta)
    y = r * np.sin(theta)

    flow = np.stack([x, y], axis=-1)

    return flow


def parse_arguments() -> Tuple[str, str]:
    """Parse input arguments."""
    parser = argparse.ArgumentParser()

    parser.add_argument(
        "frame_dir",
        type=str,
        help="Path to the directory containing subdir with RGB flow frames",
    )
    parser.add_argument(
        "flow_dir",
        type=str,
        help="Path to the root flow saving directory",
    )
    args = parser.parse_args()

    return args.frame_dir, args.flow_dir


if __name__ == "__main__":
    frame_rootdir, flow_rootdir = parse_arguments()

    # Iterate over the different directories containing flow frames
    for frame_dirname in tqdm(os.listdir(frame_rootdir)):
        frame_path_pattern = osp.join(frame_rootdir, frame_dirname, "*.png")
        # Load BGR flow frames
        frames = [
            cv2.resize(plt.imread(frame), (224, 224))
            for frame in sorted(glob(frame_path_pattern))
        ]
        # Convert flow frame to flow field
        flows = [frame_to_flow(bgr_frame) for bgr_frame in frames]

        # Save flows as pytorch tensors
        flow_dir = osp.join(flow_rootdir, frame_dirname)
        create_dir(flow_dir)
        for k in range(len(flows)):
            flow_filename = osp.join(flow_dir, str(k).zfill(4) + ".pth")
            flow_tensor = torch.from_numpy(flows[k])
            save_pth(flow_tensor, flow_filename)
